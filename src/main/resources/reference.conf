sharetrace {
  risk-propagation {
    dispatcher {
      # PinnedDispatcher must be used together with "executor = thread-pool-executor".
      type = PinnedDispatcher
      executor = "thread-pool-executor"
      # Throughput defines the maximum number of messages to be processed per actor before the thread
      # jumps to the next actor. Set to 1 for as fair as possible.
      throughput = 1000
      thread-pool-executor {
        # Allow core threads to time out.
        allow-core-timeout = off
      }
    }
  }
  user {
    transmission-rate = 0.8
    send-coefficient = 0.6
    time-buffer = 2 days
    score-time-to-live = 14 days
    contact-time-to-live = 14 days
    tolerance = 0.01
    idle-timeout = 5 seconds
    cache {
      interval = 1 day
      intervals = 28
      look-ahead-intervals = 1
      refresh-period = 1 hour
      merge-strategy = "io.sharetrace.util.cache.DefaultCacheMergeStrategy"
    }
    dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      # Throughput defines the maximum number of messages to be processed per actor before the thread
      # jumps to the next actor. Set to 1 for as fair as possible.
      throughput = 100
      thread-pool-executor {
        # Min number of threads to cap factor-based corePoolSize.
        core-pool-size-min = 2
        # Max number of threads to cap factor-based corePoolSize.
        core-pool-size-max = 32
        # The core-pool-size-factor is used to determine corePoolSize of the ThreadPoolExecutor using
        # the following formula: ceil(available processors * factor). Resulting size is then bounded by
        # the core-pool-size-min and core-pool-size-max values.
        core-pool-size-factor = 2.0
      }
    }
  }
  experiment {
    type = "standard"
    standard {
      iterations = 1
      loggable = [
        "io.sharetrace.util.logging.event.ContactEvent",
        "io.sharetrace.util.logging.event.ContactsRefreshEvent",
        "io.sharetrace.util.logging.event.CurrentRefreshEvent",
        "io.sharetrace.util.logging.event.ReceiveEvent",
        "io.sharetrace.util.logging.event.SendCachedEvent",
        "io.sharetrace.util.logging.event.SendCurrentEvent",
        "io.sharetrace.util.logging.event.UpdateEvent",
        "io.sharetrace.util.logging.metric.GraphCycles",
        "io.sharetrace.util.logging.metric.GraphEccentricity",
        "io.sharetrace.util.logging.metric.GraphScores",
        "io.sharetrace.util.logging.metric.GraphSize",
        "io.sharetrace.util.logging.metric.GraphTopology",
        "io.sharetrace.util.logging.metric.CreateUsersRuntime",
        "io.sharetrace.util.logging.metric.SendScoresRuntime",
        "io.sharetrace.util.logging.metric.SendContactsRuntime",
        "io.sharetrace.util.logging.metric.RiskPropagationRuntime",
        "io.sharetrace.util.logging.metric.MessagePassingRuntime",
        "io.sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    parameters {
      iterations = 1
      network-iterations = 1
      transmission-rates = [0.8]
      send-coefficients = [0.6]
      loggable = [
        "io.sharetrace.util.logging.event.ContactEvent",
        "io.sharetrace.util.logging.event.ContactsRefreshEvent",
        "io.sharetrace.util.logging.event.CurrentRefreshEvent",
        "io.sharetrace.util.logging.event.ReceiveEvent",
        "io.sharetrace.util.logging.event.SendCachedEvent",
        "io.sharetrace.util.logging.event.SendCurrentEvent",
        "io.sharetrace.util.logging.event.UpdateEvent",
        "io.sharetrace.util.logging.metric.GraphCycles",
        "io.sharetrace.util.logging.metric.GraphEccentricity",
        "io.sharetrace.util.logging.metric.GraphScores",
        "io.sharetrace.util.logging.metric.GraphSize",
        "io.sharetrace.util.logging.metric.CreateUsersRuntime",
        "io.sharetrace.util.logging.metric.SendScoresRuntime",
        "io.sharetrace.util.logging.metric.SendContactsRuntime",
        "io.sharetrace.util.logging.metric.RiskPropagationRuntime",
        "io.sharetrace.util.logging.metric.MessagePassingRuntime",
        "io.sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    noise {
      iterations = 1
      loggable = [
        "io.sharetrace.util.logging.event.UpdateEvent",
        "io.sharetrace.util.logging.metric.GraphSize",
        "io.sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    runtime {
      iterations = 1
      network-iterations = 1
      loggable = [
        "io.sharetrace.util.logging.metric.GraphSize",
        "io.sharetrace.util.logging.metric.CreateUsersRuntime",
        "io.sharetrace.util.logging.metric.SendScoresRuntime",
        "io.sharetrace.util.logging.metric.SendContactsRuntime",
        "io.sharetrace.util.logging.metric.RiskPropagationRuntime",
        "io.sharetrace.util.logging.metric.MessagePassingRuntime",
        "io.sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    dataset {
      context {
        seed = any
        reference-time = now
        timezone = UTC
      }
      risk-scores {
        value-source = ""
        timestamp-source = ""
      }
      contact-times {
        source = ""
        lookback-distribution = ""
        max-lookback = ""
      }
      network-topology {
        source = ""
      }
    }
  }
}