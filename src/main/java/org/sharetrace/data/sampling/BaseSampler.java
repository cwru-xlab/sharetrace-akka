package org.sharetrace.data.sampling;

import static org.sharetrace.util.Preconditions.checkArgument;
import java.util.Random;
import org.apache.commons.math3.distribution.RealDistribution;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.random.Well44497a;
import org.immutables.value.Value;
import org.sharetrace.data.factory.RandomGeneratorFactory;

abstract class BaseSampler<T> implements Sampler<T> {

  private static final String UNBOUNDED_MESSAGE =
      "Distribution must have finite lower and upper support bounds";

  protected static double normalizedSample(RealDistribution distribution) {
    double max = distribution.getSupportUpperBound();
    double min = distribution.getSupportLowerBound();
    return (distribution.sample() - min) / (max - min);
  }

  protected static void checkBoundedness(RealDistribution distribution) {
    checkArgument(
        distribution.getSupportLowerBound() != Double.NEGATIVE_INFINITY, () -> UNBOUNDED_MESSAGE);
    checkArgument(
        distribution.getSupportUpperBound() != Double.POSITIVE_INFINITY, () -> UNBOUNDED_MESSAGE);
  }

  /** Returns a pseudo-random number generator with a seed generated by {@link #seed()}. */
  @Value.Derived
  protected RandomGenerator randomGenerator() {
    return randomGeneratorFactory().getGenerator(seed());
  }

  /** Returns a factory that uses {@link #seed()} to produce {@link RandomGenerator} instances. */
  @Value.Default
  protected RandomGeneratorFactory randomGeneratorFactory() {
    return Well44497a::new;
  }

  /** Returns a seed for {@link #randomGenerator()} to create a pseudo-random number generator. */
  @Value.Default
  protected long seed() {
    return new Random().nextLong();
  }
}
