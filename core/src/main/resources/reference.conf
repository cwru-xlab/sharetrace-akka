sharetrace {
  context {
    seed = any
    random-generator-factory = "sharetrace.experiment.data.Well44497aRandomGeneratorFactory"
    reference-time = now
    timezone = UTC
  }
  coordinator {
    dispatcher {
      # PinnedDispatcher must be used together with "executor = thread-pool-executor".
      type = "PinnedDispatcher"
      executor = "thread-pool-executor"
      # Throughput defines the maximum number of messages to be processed per actor before the thread
      # jumps to the next actor. Set to 1 for as fair as possible.
      throughput = 1000
      thread-pool-executor {
        # Allow core threads to time out.
        allow-core-timeout = off
      }
    }
  }
  user {
    transmission-rate = 0.8
    send-coefficient = 1.0
    time-buffer = 2 days
    score-expiry = 14 days
    contact-expiry = 14 days
    idle-timeout = 5 seconds
    dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      # Throughput defines the maximum number of messages to be processed per actor before the thread
      # jumps to the next actor. Set to 1 for as fair as possible.
      throughput = 100
      thread-pool-executor {
        # Min number of threads to cap factor-based corePoolSize.
        core-pool-size-min = 2
        # Max number of threads to cap factor-based corePoolSize.
        core-pool-size-max = 32
        # The core-pool-size-factor is used to determine corePoolSize of the ThreadPoolExecutor using
        # the following formula: ceil(available processors * factor). Resulting size is then bounded by
        # the core-pool-size-min and core-pool-size-max values.
        core-pool-size-factor = 2.0
      }
    }
  }
  experiment {
    type = "standard"
    standard {
      iterations = 1
      loggable = [
        "sharetrace.util.logging.event.ContactEvent",
        "sharetrace.util.logging.event.ContactsRefreshEvent",
        "sharetrace.util.logging.event.ReceiveEvent",
        "sharetrace.util.logging.event.SendEvent",
        "sharetrace.util.logging.event.UpdateEvent",
        "sharetrace.util.logging.metric.GraphCycles",
        "sharetrace.util.logging.metric.GraphEccentricity",
        "sharetrace.util.logging.metric.GraphScores",
        "sharetrace.util.logging.metric.GraphSize",
        "sharetrace.util.logging.metric.GraphTopology",
        "sharetrace.util.logging.metric.CreateUsersRuntime",
        "sharetrace.util.logging.metric.SendRiskScoresRuntime",
        "sharetrace.util.logging.metric.SendContactsRuntime",
        "sharetrace.util.logging.metric.RiskPropagationRuntime",
        "sharetrace.util.logging.metric.MessagePassingRuntime",
        "sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    parameters {
      iterations = 1
      network-iterations = 1
      transmission-rates = [0.8]
      send-coefficients = [1.0]
      loggable = [
        "sharetrace.util.logging.event.ContactEvent",
        "sharetrace.util.logging.event.ContactsRefreshEvent",
        "sharetrace.util.logging.event.ReceiveEvent",
        "sharetrace.util.logging.event.SendEvent",
        "sharetrace.util.logging.event.UpdateEvent",
        "sharetrace.util.logging.metric.GraphCycles",
        "sharetrace.util.logging.metric.GraphEccentricity",
        "sharetrace.util.logging.metric.GraphScores",
        "sharetrace.util.logging.metric.GraphSize",
        "sharetrace.util.logging.metric.CreateUsersRuntime",
        "sharetrace.util.logging.metric.SendRiskScoresRuntime",
        "sharetrace.util.logging.metric.SendContactsRuntime",
        "sharetrace.util.logging.metric.RiskPropagationRuntime",
        "sharetrace.util.logging.metric.MessagePassingRuntime",
        "sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    noise {
      iterations = 1
      loggable = [
        "sharetrace.util.logging.event.UpdateEvent",
        "sharetrace.util.logging.metric.GraphSize",
        "sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    runtime {
      iterations = 1
      network-iterations = 1
      users = [100]
      loggable = [
        "sharetrace.util.logging.metric.GraphSize",
        "sharetrace.util.logging.metric.CreateUsersRuntime",
        "sharetrace.util.logging.metric.SendRiskScoresRuntime",
        "sharetrace.util.logging.metric.SendContactsRuntime",
        "sharetrace.util.logging.metric.RiskPropagationRuntime",
        "sharetrace.util.logging.metric.MessagePassingRuntime",
        "sharetrace.util.logging.setting.ExperimentSettings"
      ]
    }
    data {
      distribution {
        type = "uniform"
        normal {
          mean = 0.0
          standard-deviation = 1.0
        }
        beta {
          alpha = 2.0
          beta = 2.0
        }
        uniform {
          lower-bound = 0.0
          upper-bound = 1.0
        }
      }
      timestamps {
        look-back-distribution = ${sharetrace.experiment.data.distribution}
        backward-range = 1 day
      }
      risk-scores.value-distribution = ${sharetrace.experiment.data.distribution}
      risk-scores = ${sharetrace.experiment.data.timestamps} {backward-range = ${sharetrace.user.score-expiry}}
      network = ${sharetrace.experiment.data.timestamps} {backward-range = ${sharetrace.user.contact-expiry}}
      network {
        type = "barabasi-albert"
        gnm-random {
          nodes = 100 # Range: [1..inf)
          edges = 200 # Range: [1..inf)
        }
        random-regular {
          # (nodes * degree) must be even
          nodes = 100 # Range: [1..inf)
          degree = 2 # Range: [1..nodes)
        }
        barabasi-albert {
          initial-nodes = 2 # Range: [1..inf)
          nodes = 100 # Range: [initial-nodes..inf)
          new-edges = 2 # Range: [1..initial-nodes)
        }
        watts-strogatz {
          nodes = 100 # Range: [3..inf]
          nearest-neighbors = 3 # Range: [1..nodes - 2 + nodes mod 2); must be even
          rewiring-probability = 0.2 # Range: [0, 1]
        }
        scale-free {
          nodes = 100 # Range: [1..inf)
        }
        file {
          path = ""
          delimiter = "\\s+" # Whitespace delimiter
        }
      }
    }
  }
}